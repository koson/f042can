
_Min_Heap_Size = 0x0400;	/*1024K*/
_Min_Stack_Size = 0x0400;  /*1024K*/

/*stack will be at the begining of RAM => _estack = 0x2000000 + 0x00001000 => _estack = 0x20001000*/

MEMORY
{
  /*read/write/execution*/
	RAM (xrw)					: ORIGIN = 0x20000000, LENGTH = 6K    
	ROM (xr)					: ORIGIN = 0x08000000, LENGTH = 36K
}

SECTIONS
{
	.isr_vectors :
	{
		. = ALIGN(4);
    *(.isr_vectors)
    KEEP(*(.isr_vectors)) /* Startup code */
    . = ALIGN(4);
	} >ROM
	.text :
  {
    . = ALIGN(4);    
    *(.text)           /* .text sections (code) */
    *(.text*)          /* all text section here */
    . = ALIGN(4);
  } >ROM
  /* Constant data into ROM memory*/
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)    
    *(vtable)					/* C++ virtual tables */
    /*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
    *(.glue_7)			/* glue arm to thumb code */
    *(.glue_7t)			/* glue thumb to arm code */
    . = ALIGN(4); 
    KEEP (*(.init))
    KEEP (*(.fini))
    . = ALIGN(4); 
    
    _etext = .;    /* define a global symbols at end of code */
  } >ROM
  /*  //////// for exceptions handling
  .ARM.exidx : {
    __exidx_start = .;
     *(.ARM.exidx* .gnu.linkonce.armexidx.*) 
    __exidx_end = .;
  } >ROM 
  */
  /*
* These are the old initialisation sections, intended to contain
* naked code, with the prologue/epilogue added by crti.o/crtn.o
* when linking with startup files. The standalone startup code
* currently does not run these, better use the init arrays below.
*/
	_sidata = LOADADDR(.data);  /* Used by the startup to initialize data here wil be writed .data which then go to RAM*/

    . = ALIGN(8);
		.stack :              
	{
    . = ALIGN(8);
		_stack_begin = .;
		_StackLimit = _stack_begin + _Min_Stack_Size; 
		. = . + _Min_Stack_Size;
    _StackTop = .;  
    . = ALIGN(8);  
    PROVIDE(_estack = _StackTop);
	}>RAM	  
	
	/* Initialized data sections into RAM memory */
  .data :
  {
    . = ALIGN(4);
    _sdata = .; /* STM specific definition */ /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)
    . = ALIGN(4);
    _edata = . ;
    /*PROVIDE(current_ends = 0);*/
  } >RAM AT> ROM
  
  /* Uninitialized data section into RAM memory */   /*this section will be increase with freeRTOS stack and heap */
  . = ALIGN(4);
  .bss :
  {
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;  /* standard newlib definition */
    *(.bss)
    *(.bss*)
    *(COMMON)           /*uninitialize variables*/
    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss; /* standard newlib definition */
  } >RAM

  .heap :
	{
    . = ALIGN(4);
    _heap_start = __bss_end__;  
    /*PROVIDE(current_ends = 0);*/
    PROVIDE( end = . );                /*_sbrk uses end for malloc*/
		_heap_limit = _heap_start + _Min_Heap_Size;      
		. = . + _Min_Heap_Size;
    PROVIDE( _heap_end = . );    
	}>RAM 	
  /*_estack = ORIGIN(RAM) + LENGTH(RAM);	*/
}